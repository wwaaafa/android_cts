/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2023_21091;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.android.sts.common.SystemUtil.DEFAULT_POLL_TIME_MS;
import static com.android.sts.common.SystemUtil.poll;

import static com.google.common.truth.Truth.assertWithMessage;
import static com.google.common.truth.TruthJUnit.assume;

import android.app.Instrumentation;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.UserManager;
import android.provider.Settings;

import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.SystemUtil;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.regex.Pattern;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {
    private String mAppLocalePickerActivityName;

    @Test
    public void testPocCVE_2023_21091() {
        try {
            Instrumentation instrumentation = getInstrumentation();
            Context context = instrumentation.getContext();

            // Check if the device supports multiple users or not
            assume().withMessage("This device does not support multiple users")
                    .that(context.getSystemService(UserManager.class).supportsMultipleUsers())
                    .isTrue();

            // Retrieve Settings package name dynamically
            Intent settingsIntent = new Intent(Settings.ACTION_SETTINGS);
            ComponentName settingsComponent =
                    settingsIntent.resolveActivity(context.getPackageManager());
            String settingsPackageName =
                    settingsComponent != null
                            ? settingsComponent.getPackageName()
                            : "com.android.settings";

            // Retrieve AppLocalePickerActivity name dynamically
            Intent appLocalePickerIntent =
                    new Intent(Settings.ACTION_APP_LOCALE_SETTINGS)
                            .setData(Uri.fromParts("package", settingsPackageName, null));
            appLocalePickerIntent.setFlags(
                    Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
            ComponentName appLocalePickerComponent =
                    appLocalePickerIntent.resolveActivity(context.getPackageManager());
            mAppLocalePickerActivityName =
                    settingsPackageName + "/.localepicker.AppLocalePickerActivity";
            if (appLocalePickerComponent != null) {
                mAppLocalePickerActivityName = appLocalePickerComponent.flattenToShortString();
            }

            // Launching AppLocalePickerActivity
            context.startActivity(appLocalePickerIntent);

            // Check if vulnerable activity's UI is visible
            final long maxPollingTime = 3000;
            Pattern activityPatternByPkg =
                    Pattern.compile("mVisible=true", Pattern.CASE_INSENSITIVE);
            boolean mVisibleTrue =
                    poll(
                            () -> {
                                try {
                                    String activityDumpByPkg =
                                            SystemUtil.runShellCommand(
                                                    instrumentation,
                                                    "dumpsys activity -p "
                                                            + settingsPackageName
                                                            + " activities");
                                    if (activityPatternByPkg.matcher(activityDumpByPkg).find()) {
                                        return true;
                                    }
                                } catch (Exception e) {
                                    // ignore
                                }
                                return false;
                            },
                            DEFAULT_POLL_TIME_MS,
                            maxPollingTime);

            // Check if the currently resumed activity is the vulnerable activity
            Pattern activityPatternByActivity =
                    Pattern.compile("mResumed=true", Pattern.CASE_INSENSITIVE);
            boolean mResumedTrue =
                    poll(
                            () -> {
                                try {
                                    String activityDumpByActivity =
                                            SystemUtil.runShellCommand(
                                                    instrumentation,
                                                    "dumpsys activity "
                                                            + mAppLocalePickerActivityName);
                                    if (activityPatternByActivity
                                            .matcher(activityDumpByActivity)
                                            .find()) {
                                        return true;
                                    }
                                } catch (Exception e) {
                                    // ignore
                                }
                                return false;
                            },
                            DEFAULT_POLL_TIME_MS,
                            maxPollingTime);

            // Test fails if activity currently running and visible is the vulnerable activity
            assertWithMessage("Vulnerable to b/257954050 !!")
                    .that(mVisibleTrue && mResumedTrue)
                    .isFalse();
        } catch (Exception e) {
            assume().that(e).isNull();
        }
    }
}
