/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2023_21144;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertNull;
import static org.junit.Assume.assumeNoException;
import static org.junit.Assume.assumeTrue;

import android.app.Instrumentation;
import android.app.Notification;
import android.app.Notification.MessagingStyle;
import android.app.Notification.MessagingStyle.Message;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Person;
import android.app.StatusBarManager;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.graphics.Bitmap;
import android.graphics.drawable.Icon;
import android.net.Uri;
import android.os.Environment;
import android.os.Handler;
import android.os.HandlerThread;
import android.widget.ImageView;

import androidx.test.runner.AndroidJUnit4;
import androidx.test.uiautomator.By;
import androidx.test.uiautomator.UiDevice;
import androidx.test.uiautomator.UiObject2;
import androidx.test.uiautomator.Until;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.FileOutputStream;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {

    @Test
    public void testPocCVE_2023_21144() {
        try {
            Instrumentation instrumentation = getInstrumentation();
            Context context = instrumentation.getContext();

            try (AutoCloseable withTemporaryImage = withTemporaryImage(context)) {
                // Prepare notification channel
                NotificationChannel notificationChannel =
                        new NotificationChannel(
                                context.getString(R.string.notificationChannelId),
                                context.getString(R.string.notificationChannelName),
                                NotificationManager.IMPORTANCE_HIGH);
                NotificationManager notificationManager =
                        context.getSystemService(NotificationManager.class);
                notificationManager.createNotificationChannel(notificationChannel);

                // Prepare messaging style
                Person person =
                        new Person.Builder().setName(context.getString(R.string.username)).build();
                Message message =
                        new Message(context.getString(R.string.message), 0L /* timestamp */, person)
                                .setData(
                                        context.getString(R.string.dataMimeType),
                                        Uri.fromFile(getImageFile(context)));
                MessagingStyle messagingStyle = new MessagingStyle(person).addMessage(message);

                // Build notification
                Notification notification =
                        new Notification.Builder(context, notificationChannel.getId())
                                .setContentText(context.getString(R.string.notificationText))
                                .setSmallIcon(
                                        Icon.createWithData(
                                                new byte[0] /* data */,
                                                0 /* offset */,
                                                0 /* length */))
                                .setStyle(messagingStyle)
                                .build();

                // Register BroadcastReceiver
                Semaphore broadcastReceived = new Semaphore(0);
                BroadcastReceiver broadcastReceiver =
                        new BroadcastReceiver() {
                            @Override
                            public void onReceive(Context context, Intent intent) {
                                try {
                                    broadcastReceived.release();
                                } catch (Exception ignore) {
                                    // Ignore
                                }
                            }
                        };
                IntentFilter broadcastFilter =
                        new IntentFilter(context.getString(R.string.broadcastAction));
                context.registerReceiver(broadcastReceiver, broadcastFilter);

                // Send notification and wait for broadcast to get received
                notificationManager.notify(0 /* notification id */, notification);
                final long timeout = 10_000L;
                assumeTrue(
                        context.getString(R.string.notificationListenerNotConnected),
                        broadcastReceived.tryAcquire(timeout, TimeUnit.MILLISECONDS));

                // With fix, the notification does not contain image. Hence, using uiautomator
                // to detect the imageview to fail test
                context.getSystemService(StatusBarManager.class).expandNotificationsPanel();
                final UiDevice uiDevice = UiDevice.getInstance(instrumentation);
                UiObject2 uiObject =
                        uiDevice.wait(
                                Until.findObject(
                                        By.pkg(context.getString(R.string.systemUiPkgName))
                                                .res(context.getString(R.string.resourceId))
                                                .desc(context.getString(R.string.message))
                                                .clazz(ImageView.class.getName())),
                                timeout);
                assertNull(context.getString(R.string.failMessage), uiObject);
            }
        } catch (Exception e) {
            assumeNoException(e);
        }
    }

    private AutoCloseable withTemporaryImage(Context context) throws Exception {
        // Create a png file in a worker Thread.
        CompletableFuture<Boolean> imageIsReady = new CompletableFuture<Boolean>();
        final HandlerThread handlerThread = new HandlerThread(context.getPackageName());
        handlerThread.start();
        new Handler(handlerThread.getLooper())
                .post(
                        () -> {
                            try {
                                // The dimension of 13000 x 17000 creates png image of size ~2mb
                                // which is sufficient to extend loading time of 100ms.
                                final int sufficientlyLargeWidth = 13000;
                                final int sufficientlyLargeHeight = 17000;
                                Bitmap bitmap =
                                        Bitmap.createBitmap(
                                                sufficientlyLargeWidth,
                                                sufficientlyLargeHeight,
                                                Bitmap.Config.ARGB_8888);
                                File imageFile = getImageFile(context);
                                imageFile.createNewFile();
                                FileOutputStream fileOutputStream = new FileOutputStream(imageFile);
                                bitmap.compress(
                                        Bitmap.CompressFormat.PNG,
                                        100 /* quality */,
                                        fileOutputStream);
                                fileOutputStream.flush();
                                fileOutputStream.close();
                                imageIsReady.complete(true);
                            } catch (Exception ignore) {
                                imageIsReady.complete(false);
                            }
                        });

        // Wait until image gets created successfully
        assumeTrue(
                context.getString(R.string.fileNotCreated),
                imageIsReady.get() && getImageFile(context).exists());

        return () -> {
            File imageFile = getImageFile(context);
            if (imageFile.exists()) {
                imageFile.delete();
            }
        };
    }

    private File getImageFile(Context context) {
        return Environment.buildPath(
                Environment.getExternalStorageDirectory(),
                Environment.DIRECTORY_DOWNLOADS,
                context.getString(R.string.imageFile));
    }
}
