/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *s
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2024_0053;

import static android.Manifest.permission.CREATE_USERS;
import static android.os.UserHandle.USER_NULL;
import static android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;
import static com.android.sts.common.SystemUtil.poll;

import static com.google.common.truth.Truth.assertWithMessage;
import static com.google.common.truth.TruthJUnit.assume;

import android.app.Instrumentation;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentProvider;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.UserInfo;
import android.graphics.drawable.Icon;
import android.net.Uri;
import android.os.Build;
import android.os.UserManager;
import android.print.PrintManager;
import android.print.PrinterId;
import android.provider.Settings;
import android.util.Log;

import androidx.test.runner.AndroidJUnit4;
import androidx.test.uiautomator.By;
import androidx.test.uiautomator.BySelector;
import androidx.test.uiautomator.UiDevice;
import androidx.test.uiautomator.UiObject2;
import androidx.test.uiautomator.Until;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {

    @Test
    public void testPocCVE_2024_0053() {
        try {
            // Check if the device supports multiple users or not
            final Instrumentation instrumentation = getInstrumentation();
            final Context context = instrumentation.getContext();
            final UserManager userManager = context.getSystemService(UserManager.class);
            assume().withMessage("This device does not support multiple users")
                    .that(userManager.supportsMultipleUsers())
                    .isTrue();

            // Get the user id of "cve_2024_0053_user"
            final int userId =
                    runWithShellPermissionIdentity(
                            () -> {
                                List<UserInfo> list = userManager.getUsers();
                                for (UserInfo info : list) {
                                    if (info.toString().contains("cve_2024_0053_user")) {
                                        return info.getUserHandle().getIdentifier();
                                    }
                                }
                                return USER_NULL;
                            },
                            CREATE_USERS);
            assume().withMessage("Unable to find the user cve_2024_0053_user")
                    .that(userId)
                    .isNotEqualTo(USER_NULL);

            // Get the Image id of screenshot taken in secondary user
            String imageId = fetchImageIdFromSecondaryUser(userId);
            assume().withMessage("Could not get image id of secondary user's image")
                    .that(imageId)
                    .isNotNull();

            // Set SharedPreferences to fetch cve_2024_0053_user's userid and imageId of screenshot
            // in TestPrintService to reproduce issue
            final String currentPackageName = context.getPackageName();
            context.getSharedPreferences(currentPackageName, Context.MODE_PRIVATE)
                    .edit()
                    .putString("imageId", imageId)
                    .putInt("userId", userId)
                    .commit();

            // Launch fragment PrintSettingsFragment
            Intent intent = new Intent(Settings.ACTION_PRINT_SETTINGS);
            context.startActivity(
                    intent.setFlags(
                            Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK));

            // Wait for PrintSettingsFragment to be launched
            assume().withMessage("PrintSettingsFragment not launhced")
                    .that(
                            checkActivityLaunched(
                                    intent.resolveActivity(context.getPackageManager())
                                            .flattenToString()))
                    .isTrue();

            // Fetch and add the flag 'RECEIVER_EXPORTED' for 'TIRAMISU' and above versions to
            // keep the code consistent
            final int requiredFlag =
                    Build.VERSION.SDK_INT >= 33 /* TIRAMISU */
                            ? (int) Context.class.getField("RECEIVER_EXPORTED").get(context)
                            : 0;

            // Check if there is an exception while setting icon of Printer
            // Register a broadcast receiver to get broadcast from TestPrintService
            CompletableFuture<String> broadcastReceived = new CompletableFuture<>();
            context.registerReceiver(
                    new BroadcastReceiver() {
                        @Override
                        public void onReceive(Context context, Intent intent) {
                            try {
                                broadcastReceived.complete(intent.getStringExtra("exception"));
                            } catch (Exception e) {
                                // Ignore
                            }
                        }
                    },
                    new IntentFilter("cve_2024_0053_action"),
                    requiredFlag);

            UiDevice uiDevice = UiDevice.getInstance(instrumentation);

            // Click on "CVE_2024_0053_print" to start printer discovery session and add
            // "cve_2024_0053_printer"
            Pattern printservicePattern =
                    Pattern.compile("CVE_2024_0053_print", Pattern.CASE_INSENSITIVE);
            assume().withMessage("Printservice CVE_2024_0053_print not found")
                    .that(
                            waitForUiObject(
                                    uiDevice,
                                    By.text(printservicePattern),
                                    true /* clickRequired */))
                    .isTrue();

            // Wait for the printer to be added
            Pattern printerPattern =
                    Pattern.compile(
                            context.getString(R.string.printerName), Pattern.CASE_INSENSITIVE);
            assume().withMessage("Printer cve_2024_0053_printer not found")
                    .that(
                            waitForUiObject(
                                    uiDevice, By.text(printerPattern), false /* clickRequired */))
                    .isTrue();

            // Wait for broadcast from TestPrintService.
            String exception = broadcastReceived.get(10_000 /* timeout */, TimeUnit.MILLISECONDS);
            assume().withMessage("Exception occurred in TestPrintService " + exception)
                    .that(exception)
                    .isNull();

            // Get icon of "cve_2024_0053_printer"
            PrintManager printManager = context.getSystemService(PrintManager.class);
            PrinterId printerId =
                    new PrinterId(
                            new ComponentName(currentPackageName, TestPrintService.class.getName()),
                            context.getString(R.string.localPrinterId));
            Icon printerIcon = printManager.getCustomPrinterIcon(printerId);

            // With fix icon of "cve_2024_0053_printer" is null and without fix it is
            // cve_2024_0053_user's image
            if (printerIcon != null) {
                final String targetImageUri =
                        String.format(
                                "%s/%s",
                                ContentProvider.maybeAddUserId(EXTERNAL_CONTENT_URI, userId),
                                imageId);
                Uri secondaryUserIconUri =
                        Icon.createWithContentUri(Uri.parse(targetImageUri)).getUri();

                // Fail the test if icon of "cve_2024_0053_printer" is cve_2024_0053_user's image
                assertWithMessage(
                                "Device is vulnerable to b/281525042 hence A user can enumerate"
                                    + " and view pictures of other users providing a PrintService"
                                    + " with a custom icon")
                        .that(printerIcon.getUri())
                        .isNotEqualTo(secondaryUserIconUri);
            }
        } catch (Exception e) {
            assume().that(e).isNull();
        }
    }

    private boolean waitForUiObject(UiDevice uiDevice, BySelector selector, boolean clickRequired)
            throws Exception {
        boolean objectFound = uiDevice.wait(Until.hasObject(selector), 5000 /* timeout */);
        if (objectFound && clickRequired) {
            UiObject2 uiobject = uiDevice.findObject(selector);
            poll(() -> (uiobject.isEnabled()));
            uiobject.click();
        }
        return objectFound;
    }

    private boolean checkActivityLaunched(String activityName) throws Exception {
        final Pattern resumedPattern =
                Pattern.compile("mResumed=(?<value>(true|false))", Pattern.CASE_INSENSITIVE);
        return poll(
                () -> {
                    String dumpsys =
                            runShellCommand(String.format("dumpsys activity " + activityName));
                    Matcher matcher = resumedPattern.matcher(dumpsys);
                    if (matcher.find() && matcher.group("value").equals("true")) {
                        return true;
                    }
                    return false;
                });
    }

    private String fetchImageIdFromSecondaryUser(int userId) throws Exception {
        // Fetch the image-id of the captured screenshot image
        final Pattern pattern = Pattern.compile("_id=(?<imageId>[0-9]+)", Pattern.CASE_INSENSITIVE);
        final String imageInfoFetchingCommand =
                String.format(
                        "content query --user %d" + " --uri %s" + " --projection _id",
                        userId, EXTERNAL_CONTENT_URI);
        final CompletableFuture<String> imageId = new CompletableFuture<>();
        assume().withMessage("Failed to fetch imageId from secondary user")
                .that(
                        poll(
                                () -> {
                                    try {
                                        Matcher matcher =
                                                pattern.matcher(
                                                        runShellCommand(imageInfoFetchingCommand));
                                        if (matcher.find()) {
                                            imageId.complete(matcher.group("imageId"));
                                            return true;
                                        }
                                    } catch (Exception e) {
                                        Log.i(
                                                "CVE-2024-0053",
                                                "Got an exception while fetching the imageId : "
                                                        + e);
                                    }
                                    return false;
                                }))
                .isTrue();
        return imageId.getNow(null /* default imageId */);
    }
}
