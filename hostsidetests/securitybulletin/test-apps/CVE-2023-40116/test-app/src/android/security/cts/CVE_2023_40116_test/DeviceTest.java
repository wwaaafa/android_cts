/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2023_40116_test;

import static androidx.test.InstrumentationRegistry.getInstrumentation;

import static com.android.sts.common.SystemUtil.DEFAULT_MAX_POLL_TIME_MS;
import static com.android.sts.common.SystemUtil.poll;

import static com.google.common.truth.Truth.assertWithMessage;
import static com.google.common.truth.TruthJUnit.assume;
import static org.junit.Assume.assumeNoException;

import android.accessibilityservice.AccessibilityServiceInfo;
import android.app.Instrumentation;
import android.app.UiAutomation;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.graphics.Rect;
import android.os.Environment;

import androidx.test.runner.AndroidJUnit4;
import androidx.test.uiautomator.UiDevice;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {
    @Test
    public void testPocCVE_2023_40116() {

        try {
            Instrumentation instrumentation = getInstrumentation();

            // Enable the flag for interactive window
            final UiAutomation uiAutomation = instrumentation.getUiAutomation();
            AccessibilityServiceInfo info = uiAutomation.getServiceInfo();
            info.flags |= AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;
            uiAutomation.setServiceInfo(info);

            final UiDevice uiDevice = UiDevice.getInstance(instrumentation);

            // Fetch the bounds of pip window
            final String pipActivity = "android.security.cts.CVE_2023_40116_helper.PipActivity";
            final Rect pipWindowBound = new Rect();
            pipWindowBound.left = 0;
            assume().that(
                            poll(
                                    () -> {
                                        uiAutomation.getWindows().stream()
                                                .forEach(
                                                        window -> {
                                                            if (window.isInPictureInPictureMode()
                                                                    && window.getTitle()
                                                                            .toString()
                                                                            .equals(pipActivity)) {
                                                                window.getBoundsInScreen(
                                                                        pipWindowBound);
                                                            }
                                                        });
                                        if (pipWindowBound.left != 0) {
                                            return true;
                                        }
                                        return false;
                                    },
                                    5000L /* pollingTime */,
                                    DEFAULT_MAX_POLL_TIME_MS))
                    .isTrue();

            // Take screen shot of current screen.
            File screenShotImage =
                    Environment.buildPath(
                            Environment.getExternalStorageDirectory(),
                            Environment.DIRECTORY_DOWNLOADS,
                            "/cve_2023_40116_ScreenShot.png");

            // Vulnerability exists, if the image contains more yellow color than blue color.
            int mBlueColorPixelCount = 0;
            int mYellowColorPixelCount = 0;
            try (AutoCloseable withAScreenshotImage =
                    withAScreenshotImage(uiDevice, screenShotImage)) {
                // Compare image pixel values to detect vulnerability
                Bitmap bitmap = BitmapFactory.decodeFile(screenShotImage.getAbsolutePath());
                for (int i = pipWindowBound.top, pixelColor; i < pipWindowBound.bottom; i++) {
                    for (int j = pipWindowBound.left; j < pipWindowBound.right; j++) {
                        // Clicking screenshot may have some color defect. Hence, considering
                        // the range of ['Color.BLUE - 100', 'Color.BLUE + 100'] as Color.BLUE
                        pixelColor = bitmap.getPixel(j, i);
                        if ((pixelColor >= (Color.BLUE - 100))
                                && (pixelColor <= (Color.BLUE + 100))) {
                            mBlueColorPixelCount += 1;
                        }
                        // Clicking screenshot may have some color defect. Hence, considering
                        // the range of ['Color.YELLOW - 100', 'Color.YELLOW + 100'] as Color.YELLOW
                        if ((pixelColor >= (Color.YELLOW - 100))
                                && (pixelColor <= (Color.YELLOW + 100))) {
                            mYellowColorPixelCount += 1;
                        }
                    }
                }
            }

            // Vulnerability exists if the amount of yellow color is more than the amount
            // of blue. This is because without fix, the pip window will be so small that
            // it'll be effectively invisible and only yellow background will be present.
            // With fix, the pip window will not become small and the blue color
            // content will be more than yellow, within the pip bounds.
            assertWithMessage("Device is vulnerable to b/270368476 !!")
                    .that(mBlueColorPixelCount > mYellowColorPixelCount)
                    .isTrue();
        } catch (Exception e) {
            assumeNoException(e);
        }
    }

    private AutoCloseable withAScreenshotImage(UiDevice device, File file) {
        assume().withMessage("Screenshot was not successful")
                .that(device.takeScreenshot(file))
                .isTrue();

        // Return an AutoCloseable to remove the captured screenshot
        return () -> {
            // Remove the captured screenshot
            if (file != null && file.exists()) {
                file.delete();
            }
        };
    }
}
