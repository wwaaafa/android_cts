/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2023_40092;

import static android.Manifest.permission.CREATE_USERS;

import static androidx.test.core.app.ApplicationProvider.getApplicationContext;

import static com.google.common.truth.Truth.assertWithMessage;
import static com.google.common.truth.TruthJUnit.assume;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ShortcutInfo;
import android.content.pm.ShortcutManager;
import android.content.pm.UserInfo;
import android.os.UserManager;

import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.SystemUtil;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.lang.reflect.Field;
import java.util.List;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {

    @Test
    public void testPocCVE_2023_40092() {
        try {
            final Context context = getApplicationContext();

            // Check if the device supports multiple users or not
            final UserManager userManager = context.getSystemService(UserManager.class);
            assume().withMessage("This device does not support multiple users")
                    .that(userManager.supportsMultipleUsers())
                    .isTrue();

            // Retrieving userId of 'cve_2023_40092_user'
            int testUserId =
                    SystemUtil.runWithShellPermissionIdentity(
                            () -> {
                                List<UserInfo> list = userManager.getUsers();
                                for (UserInfo info : list) {
                                    if (info.name.contains("cve_2023_40092_user")) {
                                        return info.getUserHandle().getIdentifier();
                                    }
                                }
                                return -1;
                            },
                            CREATE_USERS);
            assume().withMessage("Unable to find the user cve_2023_40092_user")
                .that(testUserId != -1)
                .isTrue();

            // Creating a shortcut
            String pkgName = context.getPackageName();
            ShortcutInfo shortcut =
                    new ShortcutInfo.Builder(context, "cve_2023_40092_shortcut")
                            .setShortLabel("cve_2023_40092_shortcut")
                            .setIntent(new Intent("cve_2023_40092_action"))
                            .setActivity(new ComponentName(pkgName, pkgName + ".PocActivity"))
                            .build();

            // Modifying the mUserId field of shortcut
            Field UserIdField = ShortcutInfo.class.getDeclaredField("mUserId");
            UserIdField.setAccessible(true);
            UserIdField.set(shortcut, testUserId);

            // Checking whether a security exception occurs or not while publishing the shortcut
            // with the userId of a different user.
            final ShortcutManager shortcutManager = context.getSystemService(ShortcutManager.class);
            try {
                // Publishing the shortcut, as the User-Id of the calling user differs from the
                // mUserId field in the shortcut. Without fix, the shortcut will be published, while
                // with fix, it will result in a SecurityException.
                shortcutManager.pushDynamicShortcut(shortcut);
            } catch (SecurityException securityException) {
                if (securityException
                        .getLocalizedMessage()
                        .contains("User-ID in shortcut doesn't match the caller")) {
                    // SecurityException is expected with fix and hence exit the test
                    return;
                } else {
                    throw securityException;
                }
            }

            // Retrieving the List of shortcuts after publishing the shortcut
            List<ShortcutInfo> dynamicShortcuts = shortcutManager.getDynamicShortcuts();

            // Check if the shortcut is published
            for (ShortcutInfo dynamicShortcut : dynamicShortcuts) {
                // Fail the test if shortcut got published and security exception did not occur
                assertWithMessage(
                                "Device is vulnerable to b/288110451 hence malicious"
                                    + " ShortcutInfo.mUserId in 'pushDynamicShortcut' will let"
                                    + " SystemUI render owner Shortcut icon for the guest Account")
                        .that(dynamicShortcut.getId().equals("cve_2023_40092_shortcut"))
                        .isFalse();
            }
        } catch (Exception e) {
            assume().that(e).isNull();
        }
    }
}
