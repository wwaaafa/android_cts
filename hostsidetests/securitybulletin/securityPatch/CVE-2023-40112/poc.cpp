/**
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "../includes/common.h"
#include <fcntl.h>
#include "ipp.h"
#include <dlfcn.h>
#include <sys/mman.h>

int kBufferSize = 5;

static bool overloadMalloc = false;
static void *memPtr = nullptr;
static void *startPtr = nullptr;
static bool memutilsInitialized = false;
static int fd = -1;

struct sigaction new_action, old_action;

static void *(*realMalloc)(size_t) = nullptr;
static void (*realFree)(void *) = nullptr;

void sigsegv_handler(int signum, siginfo_t *info, void *context) {
    if (fd >= 0) {
        close(fd);
        fd = -1;
    }
    (*old_action.sa_sigaction)(signum, info, context);
}

void memutilsInit() {
    realMalloc = (void *(*)(size_t))dlsym(RTLD_NEXT, "malloc");
    FAIL_CHECK(nullptr != realMalloc);
    realFree = (void (*)(void *))dlsym(RTLD_NEXT, "free");
    FAIL_CHECK(nullptr != realFree);
    memutilsInitialized = true;
}

void *malloc(size_t size) {
    if (!memutilsInitialized) memutilsInit();
    if (!overloadMalloc || size != kBufferSize) return realMalloc(size);

    size_t pageSize = getpagesize();
    startPtr = (char *)memalign(pageSize, 2 * pageSize);
    mprotect((char *)startPtr + pageSize, pageSize, PROT_NONE);
    return memPtr = (char *)startPtr + pageSize - size;
}

void free(void *ptr) {
    if (!memutilsInitialized) memutilsInit();
    if (ptr == memPtr) return realFree(startPtr);
    realFree(ptr);
}

int main() {
    sigemptyset(&new_action.sa_mask);
    new_action.sa_flags = SA_SIGINFO;
    new_action.sa_sigaction = sigsegv_handler;
    sigaction(SIGSEGV, &new_action, &old_action);

    ipp_t *job;
    if ((fd = open("cve_2023_40112", O_RDONLY)) >= 0) {
        job = ippNew();

        // Without fix, an OOB read occurs in _cupsStrAlloc() of libcups.
        overloadMalloc = true;
        ippReadFile(fd, job);
        overloadMalloc = false;
        close(fd);
        fd = -1;
    }
    return EXIT_SUCCESS;
}
